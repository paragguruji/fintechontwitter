# -*- coding: utf-8 -*-
"""
Created on Thu Apr 20 14:25:42 2017

@author: Parag
"""

import os
import logging
import traceback
import sys
import datetime
from flask import Flask, request, jsonify, make_response
from fintechontwitter import conf_file_path, log_dir_path
from fintechontwitter.core import generate_trend_plot as worker_function
from logging.handlers import RotatingFileHandler
from werkzeug.exceptions import Aborter


SERVER_LOG_FILENAME = "flask_server_" + \
                      datetime.datetime.now().strftime("%Y%m%d%H%M%S") + ".log"

abort = Aborter()

application = app = Flask(__name__)


@app.route('/ping', methods=['GET'])
def index():
    """Index function to check if app is alive
    """
    return "pong"


@app.route('/api/v1.0/publishtrend', methods=['POST'])
def publish_trend():
    """API to trigger the trend analysis for posted query
    Calls the worker_function imported from core module with received params as
    args and returns its response
    :Returns: JSON Response containing:
            1. JSONified response trend graph generated by core module
    :Response format: <jsonifird plot for D3>
    :Request_URL: <base_url>/api/v1.0/publishtrend
    :Method: POST
    :Request_type: JSON
    :Request_params:
        :param entity_type:
            :type:          unicode
            :decription:    'user_mentions' or 'hashtags'
        :param time_aspect:
            :type:          unicode
            :description:   'date' / 'dayofweek' / 'hour'
        :param tags:
            :type:          list of tags or a single tag
            :description:   The target twitter handle(s) or the hashtag(s).
    :Request_format: {'entity_type': u'<authUid>',
                      'time_aspect': <(True/False)>,
                      'tags': <[<tag1>, <tag2>, ...]> OR <tag>}
    """
    if not request.json:
        print request.__dict__
        abort(400, description="aborting because empty request.json")
    if 'entity_type' not in request.json:
        abort(400, description="aborting because entity_type not in request")
    if type(request.json['entity_type']) not in [unicode, str]:
        abort(400,
              description="Aborting: entity_type is not unicode/str")
    if request.json['entity_type'].lower() not in \
       ['user_mentions', 'hashtags']:
        abort(400, description="Aborting: entity_type is neither\
              'user_mentions' nor 'hashtags'")
    if 'time_aspect' not in request.json:
        abort(400, description="aborting because time_aspect not in request")
    if type(request.json['time_aspect']) not in [unicode, str]:
        abort(400,
              description="Aborting: time_aspect is not unicode/str")
    if request.json['time_aspect'].lower() not in \
       ['date', 'dayofweek', 'hour']:
        abort(400, description="Aborting: time_aspect is neither of \
              'date', 'dayofweek', 'hour'")
    if 'tags' not in request.json:
        abort(400, description="aborting because tags not in request")
    if type(request.json['tags']) not in [unicode, str, list]:
        abort(400,
              description="Aborting: tags is not unicode/str/list")
    return make_response(jsonify(worker_function(**request.json)), 200)


@app.errorhandler(400)
def bad_request(error):
    """Handle 400 error to JSONify the response
    """
    print error.code, ': ', str(error), ' : ', error.description
    traceback.print_exc(file=sys.stdout)
    return make_response(jsonify({'error': str(error),
                                  'message': error.description}), error.code)


@app.errorhandler(404)
def not_found(error):
    """Handle 404 error to JSONify the response
    """
    print error.code, ': ', str(error), ' : ', error.description
    traceback.print_exc(file=sys.stdout)
    return make_response(jsonify({'error': str(error),
                                  'message': error.description}), error.code)


@app.errorhandler(500)
def internal_error(error):
    """Handle 500 error to JSONify the response
    """
    print 500, ': ', type(error).__name__, ' : ', str(error)
    traceback.print_exc(file=sys.stdout)
    return make_response(
            jsonify({'error': '500: InternalServerError: ' +
                              str(type(error).__name__),
                     'description': str(error),
                     'message': traceback.format_exc()}),
            500)


def unhandled_error(error):
    """Handle all unhandled error to JSONify the response
    """
    traceback.print_exc(file=sys.stdout)
    return make_response(
            jsonify({'error': str(error),
                     'description': getattr(error,
                                            'description',
                                            'No description found'),
                     'message': traceback.format_exc()}),
            getattr(error, 'code', 0))


def initiate():
    '''Initiates the required parameters for the server and starts it
    '''
    logpath = os.path.join(log_dir_path, SERVER_LOG_FILENAME)
    sys.stdout.write("*"*100 + '\n')
    sys.stdout.write("\nFind server log at: " + logpath + "\n")
    sys.stdout.flush()
    with open(logpath, 'w') as fp:
        fp.write("publishtrend server log... \n")
    handler = RotatingFileHandler(logpath, maxBytes=10000, backupCount=1)
    handler.setLevel(logging.INFO)
    application.logger.addHandler(handler)
    '''Following for loop is the safety net for all unhandled HTTP error codes.
        Ref.: http://stackoverflow.com/a/27760417
    '''
    for error in [i for i in range(400, 600) if i not in [400, 404, 500]]:
        app.error_handler_spec[None][error] = unhandled_error
    if setup_env():
        host = os.environ['SERVER_NAME'].split(':')[0].strip()
        port = int(os.environ['SERVER_NAME'].split(':')[1])
        sys.stdout.write("\nStarting publishtrend server on " +
                         os.environ['SERVER_NAME'] + "\n")
        sys.stdout.write("*"*100 + '\n')
        sys.stdout.flush()
        application.run(host=host, port=port)
    else:
        application.logger.error(
                "Failure in setting up environment and finding host")

        traceback.print_exc(file=sys.stdout)


def setup_env():
    """Sets up environment variables as specified in the file at CONF_PATH
    """
    try:
        environfile = open(conf_file_path)
    except:
        traceback.print_exc(file=sys.stdout)
        return False
    for line in environfile:
        line = line.strip()
        if line.startswith('#') or not line:
            continue
        key_val = line.split('=')
        if len(key_val) == 2:
            os.environ[key_val[0].strip()] = key_val[1].strip()
    return True


if __name__ == "__main__":
    initiate()
